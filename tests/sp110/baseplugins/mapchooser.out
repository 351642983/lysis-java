public PlVers:__version =
{
	version = 5,
	filevers = "1.10.0.6484",
	date = "04/21/2020",
	time = "18:15:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[16];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_mapchooser =
{
	name = "mapchooser",
	file = "mapchooser.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "MapChooser",
	description = "Automated Map Voting",
	author = "AlliedModders LLC",
	version = "1.10.0.6484",
	url = "http://www.sourcemod.net/"
};
new ConVar:g_Cvar_Winlimit;
new ConVar:g_Cvar_Maxrounds;
new ConVar:g_Cvar_Fraglimit;
new ConVar:g_Cvar_Bonusroundtime;
new ConVar:g_Cvar_StartTime;
new ConVar:g_Cvar_StartRounds;
new ConVar:g_Cvar_StartFrags;
new ConVar:g_Cvar_ExtendTimeStep;
new ConVar:g_Cvar_ExtendRoundStep;
new ConVar:g_Cvar_ExtendFragStep;
new ConVar:g_Cvar_ExcludeMaps;
new ConVar:g_Cvar_IncludeMaps;
new ConVar:g_Cvar_NoVoteMode;
new ConVar:g_Cvar_Extend;
new ConVar:g_Cvar_DontChange;
new ConVar:g_Cvar_EndOfMapVote;
new ConVar:g_Cvar_VoteDuration;
new ConVar:g_Cvar_RunOff;
new ConVar:g_Cvar_RunOffPercent;
new Handle:g_VoteTimer;
new Handle:g_RetryTimer;
new ArrayList:g_MapList;
new ArrayList:g_NominateList;
new ArrayList:g_NominateOwners;
new ArrayList:g_OldMapList;
new ArrayList:g_NextMapList;
new Menu:g_VoteMenu;
new g_Extends;
new g_TotalRounds;
new bool:g_HasVoteStarted;
new bool:g_WaitingForVote;
new bool:g_MapVoteCompleted;
new bool:g_ChangeMapAtRoundEnd;
new bool:g_ChangeMapInProgress;
new g_mapFileSerial = -1;
new MapChange:g_ChangeTime;
new GlobalForward:g_NominationsResetForward;
new GlobalForward:g_MapVoteStartedForward;
new g_winCount[10];
void:InitiateVote(MapChange:_arg0, ArrayList:_arg1)
{
	g_WaitingForVote = true;
	if (IsVoteInProgress(0))
	{
		new var6 = 0;
		g_RetryTimer = CreateDataTimer(5.0, 83, var6, 2);
		DataPack.WriteCell(var6, _arg0, false);
		DataPack.WriteCell(var6, _arg1, false);
		DataPack.Reset(var6, false);
		return 0;
	}
	new var1;
	if (g_MapVoteCompleted && g_ChangeMapInProgress)
	{
		return 0;
	}
	g_ChangeTime = _arg0;
	g_WaitingForVote = false;
	g_HasVoteStarted = true;
	g_VoteMenu = Menu.Menu(49, -1);
	Menu.SetTitle(g_VoteMenu, "Vote Nextmap");
	Menu.VoteResultCallback.set(g_VoteMenu, 47);
	Call_StartForward(g_MapVoteStartedForward);
	Call_Finish(0);
	new var7 = 0;
	if (_arg1)
	{
		new var18;
		var18 = ArrayList.Length.get(_arg1);
		new var19 = 0;
		while (var19 < var18)
		{
			ArrayList.GetString(_arg1, var19, var7, 256);
			if (IsMapValid(var7))
			{
				new var20 = 0;
				GetMapDisplayName(var7, var20, 256);
				Menu.AddItem(g_VoteMenu, var7, var20, 0);
			}
			var19++;
		}
	}
	else
	{
		new var8;
		var8 = ArrayList.Length.get(g_NominateList);
		new var9;
		var9 = ConVar.IntValue.get(g_Cvar_IncludeMaps);
		new var10;
		new var2;
		if (var8 >= var9)
		{
			var2 = var9;
		}
		else
		{
			var2 = var8;
		}
		var10 = var2;
		new var11 = 0;
		while (var11 < var10)
		{
			new var12 = 0;
			ArrayList.GetString(g_NominateList, var11, var7, 256);
			GetMapDisplayName(var7, var12, 256);
			Menu.AddItem(g_VoteMenu, var7, var12, 0);
			RemoveStringFromArray(g_NextMapList, var7);
			Call_StartForward(g_NominationsResetForward);
			Call_PushString(var7);
			Call_PushCell(ArrayList.Get(g_NominateOwners, var11, 0, false));
			Call_Finish(0);
			var11++;
		}
		new var13;
		var13 = var10;
		while (var13 < var8)
		{
			ArrayList.GetString(g_NominateList, var13, var7, 256);
			Call_StartForward(g_NominationsResetForward);
			Call_PushString(var7);
			Call_PushCell(ArrayList.Get(g_NominateOwners, var13, 0, false));
			Call_Finish(0);
			var13++;
		}
		new var14;
		var14 = var10;
		new var15 = 0;
		new var16;
		var16 = ArrayList.Length.get(g_NextMapList);
		while (var14 < var9)
		{
			if (!(var15 >= var16))
			{
				ArrayList.GetString(g_NextMapList, var15, var7, 256);
				var15++;
				new var17 = 0;
				GetMapDisplayName(var7, var17, 256);
				Menu.AddItem(g_VoteMenu, var7, var17, 0);
				var14++;
			}
			ArrayList.Clear(g_NominateOwners);
			ArrayList.Clear(g_NominateList);
		}
		ArrayList.Clear(g_NominateOwners);
		ArrayList.Clear(g_NominateList);
	}
	new var3;
	if ((_arg0 && _arg0 == 1) && ConVar.BoolValue.get(g_Cvar_DontChange))
	{
		Menu.AddItem(g_VoteMenu, "##dontchange##", "Don't Change", 0);
	}
	else
	{
		new var5;
		if (ConVar.BoolValue.get(g_Cvar_Extend) && g_Extends < ConVar.IntValue.get(g_Cvar_Extend))
		{
			Menu.AddItem(g_VoteMenu, "##extend##", "Extend Map", 0);
		}
	}
	if (Menu.ItemCount.get(g_VoteMenu))
	{
		new var21;
		var21 = ConVar.IntValue.get(g_Cvar_VoteDuration);
		Menu.ExitButton.set(g_VoteMenu, false);
		Menu.DisplayVoteToAll(g_VoteMenu, var21, 0);
		LogAction(-1, -1, "Voting for next map has started.");
		PrintToChatAll("[SM] %t", 5364);
		return 0;
	}
	g_HasVoteStarted = false;
	CloseHandle(g_VoteMenu);
	g_VoteMenu = 0;
	return 0;
}

bool:RemoveStringFromArray(ArrayList:_arg0, String:_arg1[])
{
	new var1;
	var1 = ArrayList.FindString(_arg0, _arg1[0]);
	if (var1 != -1)
	{
		ArrayList.Erase(_arg0, var1);
		return 1;
	}
	return 0;
}

void:CreateNextVote()
{
	ArrayList.Clear(g_NextMapList);
	new var3 = 0;
	new var4;
	var4 = ArrayList.ArrayList(ByteCountToCells(256), 0);
	new var5 = 0;
	while (ArrayList.Length.get(g_MapList) > var5)
	{
		ArrayList.GetString(g_MapList, var5, var3, 256);
		if (FindMap(var3, var3, 256) != 1)
		{
			ArrayList.PushString(var4, var3);
		}
		var5++;
	}
	GetCurrentMap(var3, 256);
	RemoveStringFromArray(var4, var3);
	new var1;
	if (ConVar.IntValue.get(g_Cvar_ExcludeMaps) && ArrayList.Length.get(var4) > ConVar.IntValue.get(g_Cvar_ExcludeMaps))
	{
		new var6 = 0;
		while (ArrayList.Length.get(g_OldMapList) > var6)
		{
			ArrayList.GetString(g_OldMapList, var6, var3, 256);
			RemoveStringFromArray(var4, var3);
			var6++;
		}
	}
	new var7;
	new var2;
	if (ConVar.IntValue.get(g_Cvar_IncludeMaps) < ArrayList.Length.get(var4))
	{
		var2 = ConVar.IntValue.get(g_Cvar_IncludeMaps);
	}
	else
	{
		var2 = ArrayList.Length.get(var4);
	}
	var7 = var2;
	new var8 = 0;
	while (var8 < var7)
	{
		new var9;
		var9 = GetRandomInt(0, ArrayList.Length.get(var4) + -1);
		ArrayList.GetString(var4, var9, var3, 256);
		ArrayList.PushString(g_NextMapList, var3);
		ArrayList.Erase(var4, var9);
		var8++;
	}
	CloseHandle(var4);
	var4 = 0;
	return 0;
}

bool:CanVoteStart()
{
	new var1;
	if (g_WaitingForVote || g_HasVoteStarted)
	{
		return 0;
	}
	return 1;
}

NominateResult:InternalNominateMap(String:_arg0[], bool:_arg1, _arg2)
{
	if (IsMapValid(_arg0[0]))
	{
		if (ArrayList.FindString(g_NominateList, _arg0[0]) != -1)
		{
			return 2;
		}
		new var3 = 0;
		new var1;
		if (_arg2 && (var3 = ArrayList.FindValue(g_NominateOwners, _arg2, 0)) != -1)
		{
			new var4 = 0;
			ArrayList.GetString(g_NominateList, var3, var4, 256);
			Call_StartForward(g_NominationsResetForward);
			Call_PushString(var4);
			Call_PushCell(_arg2);
			Call_Finish(0);
			ArrayList.SetString(g_NominateList, var3, _arg0[0]);
			return 1;
		}
		new var2;
		if (ArrayList.Length.get(g_NominateList) >= ConVar.IntValue.get(g_Cvar_IncludeMaps) && _arg1)
		{
			return 4;
		}
		ArrayList.PushString(g_NominateList, _arg0[0]);
		ArrayList.Push(g_NominateOwners, _arg2);
		while (ConVar.IntValue.get(g_Cvar_IncludeMaps) < ArrayList.Length.get(g_NominateList))
		{
			new var5 = 0;
			ArrayList.GetString(g_NominateList, 0, var5, 256);
			Call_StartForward(g_NominationsResetForward);
			Call_PushString(var5);
			Call_PushCell(ArrayList.Get(g_NominateOwners, 0, 0, false));
			Call_Finish(0);
			ArrayList.Erase(g_NominateList, 0);
			ArrayList.Erase(g_NominateOwners, 0);
		}
		return 0;
	}
	return 3;
}

bool:InternalRemoveNominationByMap(String:_arg0[])
{
	new var1 = 0;
	while (ArrayList.Length.get(g_NominateList) > var1)
	{
		new var2 = 0;
		ArrayList.GetString(g_NominateList, var1, var2, 256);
		if (!(strcmp(_arg0[0], var2, false)))
		{
			Call_StartForward(g_NominationsResetForward);
			Call_PushString(var2);
			Call_PushCell(ArrayList.Get(g_NominateOwners, var1, 0, false));
			Call_Finish(0);
			ArrayList.Erase(g_NominateList, var1);
			ArrayList.Erase(g_NominateOwners, var1);
			return 1;
		}
		var1++;
	}
	return 0;
}

bool:InternalRemoveNominationByOwner(_arg0)
{
	new var2 = 0;
	new var1;
	if (_arg0 && (var2 = ArrayList.FindValue(g_NominateOwners, _arg0, 0)) != -1)
	{
		new var3 = 0;
		ArrayList.GetString(g_NominateList, var2, var3, 256);
		Call_StartForward(g_NominationsResetForward);
		Call_PushString(var3);
		Call_PushCell(_arg0);
		Call_Finish(0);
		ArrayList.Erase(g_NominateList, var2);
		ArrayList.Erase(g_NominateOwners, var2);
		return 1;
	}
	return 0;
}

Float:5*0(Float:_arg0, _arg1)
{
	return _arg0 * float(_arg1);
}

bool:StrEqual(String:_arg0[], String:_arg1[], bool:_arg2)
{
	return strcmp(_arg0[0], _arg1[0], _arg2) == 0;
}

Handle:CreateDataTimer(Float:_arg0, <typeset 0>:_arg1, Handle:_arg2, _arg3)
{
	_arg2 = DataPack.DataPack();
	_arg3 |= 512;
	return CreateTimer(_arg0, _arg1, _arg2, _arg3);
}

bool:Menu.DisplayVoteToAll(Menu:_arg0, _arg1, _arg2)
{
	new var2 = 0;

/* ERROR! null */
 function "Menu.DisplayVoteToAll" (number 10)

void:PrintToChatAll(String:_arg0[], any:_arg1)
{
	new var1 = 0;
	new var2 = 1;
	while (var2 <= MaxClients)
	{
		if (IsClientInGame(var2))
		{
			SetGlobalTransTarget(var2);
			VFormat(var1, 254, _arg0[0], 2);
			PrintToChat(var2, "%s", var1);
		}
		var2++;
	}
	return 0;
}

ByteCountToCells(_arg0)
{
	if (_arg0)
	{
		return _arg0 + 3 / 4;
	}
	return 1;
}

void:SetupTimeleftTimer()
{
	new var3 = 0;
	new var1;
	if (GetMapTimeLeft(var3) && var3 > 0)
	{
		new var4;
		var4 = ConVar.IntValue.get(g_Cvar_StartTime) * 60;
		new var2;
		if (var3 - var4 < 0 && ConVar.BoolValue.get(g_Cvar_EndOfMapVote) && g_MapVoteCompleted && g_HasVoteStarted)
		{
			InitiateVote(2, 0);
		}
		else
		{
			if (g_VoteTimer)
			{
				KillTimer(g_VoteTimer, false);
				g_VoteTimer = 0;
			}
			new var5 = 0;
			g_VoteTimer = CreateDataTimer(float(var3 - var4), 83, var5, 2);
			DataPack.WriteCell(var5, 2, false);
			DataPack.WriteCell(var5, 0, false);
			DataPack.Reset(var5, false);
		}
	}
	return 0;
}

public APLRes:AskPluginLoad2(Handle:_arg0, bool:_arg1, String:_arg2[], _arg3)
{
	RegPluginLibrary("mapchooser");
	CreateNative("NominateMap", 65);
	CreateNative("RemoveNominationByMap", 67);
	CreateNative("RemoveNominationByOwner", 69);
	CreateNative("InitiateMapChooserVote", 63);
	CreateNative("CanMapChooserStartVote", 53);
	CreateNative("HasEndOfMapVoteFinished", 55);
	CreateNative("GetExcludeMapList", 59);
	CreateNative("GetNominatedMapList", 61);
	CreateNative("EndOfMapVoteEnabled", 57);
	return 0;
}

public void:CheckMaxRounds(_arg0)
{
	if (g_Cvar_Maxrounds)
	{
		new var1;
		var1 = ConVar.IntValue.get(g_Cvar_Maxrounds);
		if (var1)
		{
			if (var1 - ConVar.IntValue.get(g_Cvar_StartRounds) <= _arg0)
			{
				InitiateVote(2, 0);
			}
		}
	}
	return 0;
}

public void:CheckWinLimit(_arg0)
{
	if (g_Cvar_Winlimit)
	{
		new var1;
		var1 = ConVar.IntValue.get(g_Cvar_Winlimit);
		if (var1)
		{
			if (var1 - ConVar.IntValue.get(g_Cvar_StartRounds) <= _arg0)
			{
				InitiateVote(2, 0);
			}
		}
	}
	return 0;
}

public Action:Command_Mapvote(_arg0, _arg1)
{
	InitiateVote(2, 0);
	return 3;
}

public Action:Command_SetNextmap(_arg0, _arg1)
{
	if (_arg1 < 1)
	{
		ReplyToCommand(_arg0, "[SM] Usage: sm_setnextmap <map>");
		return 3;
	}
	new var1 = 0;
	new var2 = 0;
	GetCmdArg(1, var1, 256);
	if (FindMap(var1, var2, 256) == 1)
	{
		ReplyToCommand(_arg0, "[SM] %t", "Map was not found", var1);
		return 3;
	}
	GetMapDisplayName(var2, var2, 256);
	ShowActivity2(_arg0, "[SM] ", "%t", "Changed Next Map", var2);
	LogAction(_arg0, -1, "\"%L\" changed nextmap to \"%s\"", _arg0, var1);
	SetNextMap(var1);
	g_MapVoteCompleted = true;
	return 3;
}

public void:Event_PlayerDeath(Event:_arg0, String:_arg1[], bool:_arg2)
{
	new var1;
	if (ArrayList.Length.get(g_MapList) && g_Cvar_Fraglimit && g_HasVoteStarted)
	{
		return 0;
	}
	new var2;
	if (ConVar.IntValue.get(g_Cvar_Fraglimit) && ConVar.BoolValue.get(g_Cvar_EndOfMapVote))
	{
		return 0;
	}
	if (g_MapVoteCompleted)
	{
		return 0;
	}
	new var3;
	var3 = GetClientOfUserId(Event.GetInt(_arg0, "attacker", 0));
	if (var3)
	{
		if (ConVar.IntValue.get(g_Cvar_Fraglimit) - ConVar.IntValue.get(g_Cvar_StartFrags) <= GetClientFrags(var3))
		{
			InitiateVote(2, 0);
		}
		return 0;
	}
	return 0;
}

public void:Event_RoundEnd(Event:_arg0, String:_arg1[], bool:_arg2)
{
	if (g_ChangeMapAtRoundEnd)
	{
		g_ChangeMapAtRoundEnd = false;
		CreateTimer(2.0, 81, 0, 2);
		g_ChangeMapInProgress = true;
	}
	new var3 = 0;
	if (strcmp(_arg1[0], "round_win", true))
	{
		var3 = Event.GetInt(_arg0, "winner", 0);
	}
	else
	{
		var3 = Event.GetInt(_arg0, "team", 0);
	}
	new var1;
	if (var3 && var3 == 1 && ConVar.BoolValue.get(g_Cvar_EndOfMapVote))
	{
		return 0;
	}
	if (var3 >= 10)
	{
		SetFailState("Mod exceed maximum team count - Please file a bug report.");
	}
	g_TotalRounds += 1;
	g_winCount[var3]++;
	new var2;
	if (ArrayList.Length.get(g_MapList) && g_HasVoteStarted && g_MapVoteCompleted)
	{
		return 0;
	}
	CheckWinLimit(g_winCount[var3]);
	CheckMaxRounds(g_TotalRounds);
	return 0;
}

public void:Event_TFRestartRound(Event:_arg0, String:_arg1[], bool:_arg2)
{
	g_TotalRounds = 0;
	return 0;
}

public void:Event_TeamPlayWinPanel(Event:_arg0, String:_arg1[], bool:_arg2)
{
	if (g_ChangeMapAtRoundEnd)
	{
		g_ChangeMapAtRoundEnd = false;
		CreateTimer(2.0, 81, 0, 2);
		g_ChangeMapInProgress = true;
	}
	new var3;
	var3 = Event.GetInt(_arg0, "blue_score", 0);
	new var4;
	var4 = Event.GetInt(_arg0, "red_score", 0);
	new var1;
	if (Event.GetInt(_arg0, "round_complete", 0) == 1 || StrEqual(_arg1[0], "arena_win_panel", true))
	{
		g_TotalRounds += 1;
		new var2;
		if (ArrayList.Length.get(g_MapList) && g_HasVoteStarted && g_MapVoteCompleted && ConVar.BoolValue.get(g_Cvar_EndOfMapVote))
		{
			return 0;
		}
		CheckMaxRounds(g_TotalRounds);
		switch (Event.GetInt(_arg0, "winning_team", 0))
		{
			case 2:
			{
				CheckWinLimit(var4);
			}
			case 3:
			{
				CheckWinLimit(var3);
			}
			default:
			{
				return 0;
			}
		}
	}
	return 0;
}

public void:Handler_MapVoteFinished(Menu:_arg0, _arg1, _arg2, _arg3[][], _arg4, _arg5[][])
{
	new var1;
	if (ConVar.BoolValue.get(g_Cvar_RunOff) && _arg4 > 1)
	{
		new var2;
		var2 = float(_arg5[0][0] + 4/* ERROR unknown load Binary */);
		new var3;
		var3 = 5*0(ConVar.FloatValue.get(g_Cvar_RunOffPercent) / 100.0, _arg1);
		if (var2 < var3)
		{
			g_VoteMenu = Menu.Menu(49, -1);
			Menu.SetTitle(g_VoteMenu, "Runoff Vote Nextmap");
			Menu.VoteResultCallback.set(g_VoteMenu, 51);
			new var4 = 0;
			new var5 = 0;
			new var6 = 0;
			Menu.GetItem(_arg0, _arg5[0][0], var4, 256, 0, var5, 256);
			Menu.AddItem(g_VoteMenu, var4, var5, 0);
			Menu.GetItem(_arg0, _arg5[0][1], var4, 256, 0, var6, 256);
			Menu.AddItem(g_VoteMenu, var4, var6, 0);
			new var7;
			var7 = ConVar.IntValue.get(g_Cvar_VoteDuration);
			Menu.ExitButton.set(g_VoteMenu, false);
			Menu.DisplayVoteToAll(g_VoteMenu, var7, 0);
			new var8;
			var8 = 5*0(float(_arg5[0][0] + 4/* ERROR unknown load Binary */) / float(_arg1), 100);
			new var9;
			var9 = 5*0(float(_arg5[0][1] + 4/* ERROR unknown load Binary */) / float(_arg1), 100);
			PrintToChatAll("[SM] %t", "Starting Runoff", ConVar.FloatValue.get(g_Cvar_RunOffPercent), var5, var8, var6, var9);
			LogMessage("Voting for next map was indecisive, beginning runoff vote");
			return 0;
		}
	}
	Handler_VoteFinishedGeneric(_arg0, _arg1, _arg2, _arg3[0], _arg4, _arg5[0]);
	return 0;
}

public Handler_MapVoteMenu(Menu:_arg0, MenuAction:_arg1, _arg2, _arg3)
{
	switch (_arg1)
	{
		case 2:
		{
			new var9 = 0;
			Format(var9, 255, "%T", "Vote Nextmap", _arg2);
			new var10;
			var10 = _arg3;
			Panel.SetTitle(var10, var9, false);
		}
		case 16:
		{
			g_VoteMenu = 0;
			CloseHandle(_arg0);
			_arg0 = 0;
		}
		case 128:
		{
			new var1;
			if (_arg2 == -2 && ConVar.BoolValue.get(g_Cvar_NoVoteMode))
			{
				new var6;
				var6 = Menu.ItemCount.get(_arg0);
				new var7 = 0;
				Menu.GetItem(_arg0, 0, var7, 256, 0, "", 0);
				new var2;
				if (strcmp(var7, "##extend##", false) && strcmp(var7, "##dontchange##", false))
				{
					new var8;
					var8 = GetRandomInt(0, var6 + -1);
					Menu.GetItem(_arg0, var8, var7, 256, 0, "", 0);
					while (strcmp(var7, "##extend##", false) && strcmp(var7, "##dontchange##", false))
					{
						var8 = GetRandomInt(0, var6 + -1);
						Menu.GetItem(_arg0, var8, var7, 256, 0, "", 0);
					}
					SetNextMap(var7);
					g_MapVoteCompleted = true;
				}
			}
			g_HasVoteStarted = false;
		}
		case 512:
		{
			if (_arg3 == Menu.ItemCount.get(_arg0) + -1)
			{
				new var4 = 0;
				new var5 = 0;
				Menu.GetItem(_arg0, _arg3, var4, 256, 0, "", 0);
				if (strcmp(var4, "##extend##", false))
				{
					if (!(strcmp(var4, "##dontchange##", false)))
					{
						Format(var5, 255, "%T", "Dont Change", _arg2);
						return RedrawMenuItem(var5);
					}
				}
				Format(var5, 255, "%T", "Extend Map", _arg2);
				return RedrawMenuItem(var5);
			}
		}
		default:
		{
		}
	}
	return 0;
}

public void:Handler_VoteFinishedGeneric(Menu:_arg0, _arg1, _arg2, _arg3[][], _arg4, _arg5[][])
{
	new var1 = 0;
	new var2 = 0;
	Menu.GetItem(_arg0, _arg5[0][0], var1, 256, 0, var2, 256);
	if (strcmp(var1, "##extend##", false))
	{
		if (strcmp(var1, "##dontchange##", false))
		{
			if (g_ChangeTime == 2)
			{
				SetNextMap(var1);
			}
			else
			{
				if (g_ChangeTime)
				{
					SetNextMap(var1);
					g_ChangeMapAtRoundEnd = true;
				}
				new var7 = 0;
				CreateDataTimer(2.0, 81, var7, 0);
				DataPack.WriteString(var7, var1, false);
				g_ChangeMapInProgress = false;
			}
			g_HasVoteStarted = false;
			g_MapVoteCompleted = true;
			PrintToChatAll("[SM] %t", "Nextmap Voting Finished", var2, RoundToFloor(5*0(float(_arg5[0][0] + 4/* ERROR unknown load Binary */) / float(_arg1), 100)), _arg1);
			LogAction(-1, -1, "Voting for next map has finished. Nextmap: %s.", var1);
		}
		PrintToChatAll("[SM] %t", "Current Map Stays", RoundToFloor(5*0(float(_arg5[0][0] + 4/* ERROR unknown load Binary */) / float(_arg1), 100)), _arg1);
		LogAction(-1, -1, "Voting for next map has finished. 'No Change' was the winner");
		g_HasVoteStarted = false;
		CreateNextVote();
		SetupTimeleftTimer();
	}
	else
	{
		g_Extends += 1;
		new var3 = 0;
		if (GetMapTimeLimit(var3))
		{
			if (0 < var3)
			{
				ExtendMapTimeLimit(ConVar.IntValue.get(g_Cvar_ExtendTimeStep) * 60);
			}
		}
		if (g_Cvar_Winlimit)
		{
			new var4;
			var4 = ConVar.IntValue.get(g_Cvar_Winlimit);
			if (var4)
			{
				ConVar.IntValue.set(g_Cvar_Winlimit, ConVar.IntValue.get(g_Cvar_ExtendRoundStep) + var4);
			}
		}
		if (g_Cvar_Maxrounds)
		{
			new var5;
			var5 = ConVar.IntValue.get(g_Cvar_Maxrounds);
			if (var5)
			{
				ConVar.IntValue.set(g_Cvar_Maxrounds, ConVar.IntValue.get(g_Cvar_ExtendRoundStep) + var5);
			}
		}
		if (g_Cvar_Fraglimit)
		{
			new var6;
			var6 = ConVar.IntValue.get(g_Cvar_Fraglimit);
			if (var6)
			{
				ConVar.IntValue.set(g_Cvar_Fraglimit, ConVar.IntValue.get(g_Cvar_ExtendFragStep) + var6);
			}
		}
		PrintToChatAll("[SM] %t", "Current Map Extended", RoundToFloor(5*0(float(_arg5[0][0] + 4/* ERROR unknown load Binary */) / float(_arg1), 100)), _arg1);
		LogAction(-1, -1, "Voting for next map has finished. The current map has been extended.");
		g_HasVoteStarted = false;
		CreateNextVote();
		SetupTimeleftTimer();
	}
	return 0;
}

public Native_CanVoteStart(Handle:_arg0, _arg1)
{
	return CanVoteStart();
}

public Native_CheckVoteDone(Handle:_arg0, _arg1)
{
	return g_MapVoteCompleted;
}

public Native_EndOfMapVoteEnabled(Handle:_arg0, _arg1)
{
	return ConVar.BoolValue.get(g_Cvar_EndOfMapVote);
}

public Native_GetExcludeMapList(Handle:_arg0, _arg1)
{
	new var1;
	var1 = GetNativeCell(1);
	if (var1)
	{
		new var2;
		var2 = ArrayList.Length.get(g_OldMapList);
		new var3 = 0;
		new var4 = 0;
		while (var4 < var2)
		{
			ArrayList.GetString(g_OldMapList, var4, var3, 256);
			ArrayList.PushString(var1, var3);
			var4++;
		}
		return 0;
	}
	return 0;
}

public Native_GetNominatedMapList(Handle:_arg0, _arg1)
{
	new var1;
	var1 = GetNativeCell(1);
	new var2;
	var2 = GetNativeCell(2);
	if (var1)
	{
		new var3 = 0;
		new var4 = 0;
		while (ArrayList.Length.get(g_NominateList) > var4)
		{
			ArrayList.GetString(g_NominateList, var4, var3, 256);
			ArrayList.PushString(var1, var3);
			if (var2)
			{
				new var5;
				var5 = ArrayList.Get(g_NominateOwners, var4, 0, false);
				ArrayList.Push(var2, var5);
			}
			var4++;
		}
		return 0;
	}
	return 0;
}

public Native_InitiateVote(Handle:_arg0, _arg1)
{
	new var1;
	var1 = GetNativeCell(1);
	new var2;
	var2 = GetNativeCell(2);
	LogAction(-1, -1, "Starting map vote because outside request");
	InitiateVote(var1, var2);
	return 0;
}

public Native_NominateMap(Handle:_arg0, _arg1)
{
	new var1 = 0;
	GetNativeStringLength(1, var1);
	if (0 >= var1)
	{
		return 0;
	}

/* ERROR! null */
 function "Native_NominateMap" (number 32)

public Native_RemoveNominationByMap(Handle:_arg0, _arg1)
{
	new var1 = 0;
	GetNativeStringLength(1, var1);
	if (0 >= var1)
	{
		return 0;
	}

/* ERROR! null */
 function "Native_RemoveNominationByMap" (number 33)

public Native_RemoveNominationByOwner(Handle:_arg0, _arg1)
{
	return InternalRemoveNominationByOwner(GetNativeCell(1));
}

public void:OnClientDisconnect(_arg0)
{
	new var1;
	var1 = ArrayList.FindValue(g_NominateOwners, _arg0, 0);
	if (var1 == -1)
	{
		return 0;
	}
	new var2 = 0;
	ArrayList.GetString(g_NominateList, var1, var2, 256);
	Call_StartForward(g_NominationsResetForward);
	Call_PushString(var2);
	Call_PushCell(ArrayList.Get(g_NominateOwners, var1, 0, false));
	Call_Finish(0);
	ArrayList.Erase(g_NominateOwners, var1);
	ArrayList.Erase(g_NominateList, var1);
	return 0;
}

public void:OnConfigsExecuted()
{
	if (ReadMapList(g_MapList, g_mapFileSerial, "mapchooser", 3))
	{
		if (g_mapFileSerial == -1)
		{
			LogError("Unable to create a valid map list.");
		}
	}
	CreateNextVote();
	SetupTimeleftTimer();
	g_TotalRounds = 0;
	g_Extends = 0;
	g_MapVoteCompleted = false;
	ArrayList.Clear(g_NominateList);
	ArrayList.Clear(g_NominateOwners);
	new var2 = 0;
	while (var2 < 10)
	{
		g_winCount[var2] = 0;
		var2++;
	}
	new var1;
	if (g_Cvar_Bonusroundtime && ConVar.IntValue.get(g_Cvar_StartRounds))
	{
		if (ConVar.FloatValue.get(g_Cvar_Bonusroundtime) <= ConVar.FloatValue.get(g_Cvar_VoteDuration))
		{
			LogError("Warning - Bonus Round Time shorter than Vote Time. Votes during bonus round may not have time to complete");
		}
	}
	return 0;
}

public void:OnMapEnd()
{
	g_HasVoteStarted = false;
	g_WaitingForVote = false;
	g_ChangeMapAtRoundEnd = false;
	g_ChangeMapInProgress = false;
	g_VoteTimer = 0;
	g_RetryTimer = 0;
	new var1 = 0;
	GetCurrentMap(var1, 256);
	ArrayList.PushString(g_OldMapList, var1);
	if (ConVar.IntValue.get(g_Cvar_ExcludeMaps) < ArrayList.Length.get(g_OldMapList))
	{
		ArrayList.Erase(g_OldMapList, 0);
	}
	return 0;
}

public void:OnMapTimeLeftChanged()
{
	if (ArrayList.Length.get(g_MapList))
	{
		SetupTimeleftTimer();
	}
	return 0;
}

public void:OnPluginStart()
{
	LoadTranslations("mapchooser.phrases");
	LoadTranslations("common.phrases");
	new var2;
	var2 = ByteCountToCells(256);
	g_MapList = ArrayList.ArrayList(var2, 0);
	g_NominateList = ArrayList.ArrayList(var2, 0);
	g_NominateOwners = ArrayList.ArrayList(1, 0);
	g_OldMapList = ArrayList.ArrayList(var2, 0);
	g_NextMapList = ArrayList.ArrayList(var2, 0);
	g_Cvar_EndOfMapVote = CreateConVar("sm_mapvote_endvote", "1", "Specifies if MapChooser should run an end of map vote", 0, true, 0.0, true, 1.0);
	g_Cvar_StartTime = CreateConVar("sm_mapvote_start", "3.0", "Specifies when to start the vote based on time remaining.", 0, true, 1.0, false, 0.0);
	g_Cvar_StartRounds = CreateConVar("sm_mapvote_startround", "2.0", "Specifies when to start the vote based on rounds remaining. Use 0 on TF2 to start vote during bonus round time", 0, true, 0.0, false, 0.0);
	g_Cvar_StartFrags = CreateConVar("sm_mapvote_startfrags", "5.0", "Specifies when to start the vote base on frags remaining.", 0, true, 1.0, false, 0.0);
	g_Cvar_ExtendTimeStep = CreateConVar("sm_extendmap_timestep", "15", "Specifies how much many more minutes each extension makes", 0, true, 5.0, false, 0.0);
	g_Cvar_ExtendRoundStep = CreateConVar("sm_extendmap_roundstep", "5", "Specifies how many more rounds each extension makes", 0, true, 1.0, false, 0.0);
	g_Cvar_ExtendFragStep = CreateConVar("sm_extendmap_fragstep", "10", "Specifies how many more frags are allowed when map is extended.", 0, true, 5.0, false, 0.0);
	g_Cvar_ExcludeMaps = CreateConVar("sm_mapvote_exclude", "5", "Specifies how many past maps to exclude from the vote.", 0, true, 0.0, false, 0.0);
	g_Cvar_IncludeMaps = CreateConVar("sm_mapvote_include", "5", "Specifies how many maps to include in the vote.", 0, true, 2.0, true, 6.0);
	g_Cvar_NoVoteMode = CreateConVar("sm_mapvote_novote", "1", "Specifies whether or not MapChooser should pick a map if no votes are received.", 0, true, 0.0, true, 1.0);
	g_Cvar_Extend = CreateConVar("sm_mapvote_extend", "0", "Number of extensions allowed each map.", 0, true, 0.0, false, 0.0);
	g_Cvar_DontChange = CreateConVar("sm_mapvote_dontchange", "1", "Specifies if a 'Don't Change' option should be added to early votes", 0, true, 0.0, false, 0.0);
	g_Cvar_VoteDuration = CreateConVar("sm_mapvote_voteduration", "20", "Specifies how long the mapvote should be available for.", 0, true, 5.0, false, 0.0);
	g_Cvar_RunOff = CreateConVar("sm_mapvote_runoff", "0", "Hold runoff votes if winning choice is less than a certain margin", 0, true, 0.0, true, 1.0);
	g_Cvar_RunOffPercent = CreateConVar("sm_mapvote_runoffpercent", "50", "If winning choice has less than this percent of votes, hold a runoff", 0, true, 0.0, true, 100.0);
	RegAdminCmd("sm_mapvote", 35, 64, "sm_mapvote - Forces MapChooser to attempt to run a map vote now.", "", 0);
	RegAdminCmd("sm_setnextmap", 37, 64, "sm_setnextmap <map>", "", 0);
	g_Cvar_Winlimit = FindConVar("mp_winlimit");
	g_Cvar_Maxrounds = FindConVar("mp_maxrounds");
	g_Cvar_Fraglimit = FindConVar("mp_fraglimit");
	g_Cvar_Bonusroundtime = FindConVar("mp_bonusroundtime");
	new var1;
	if (g_Cvar_Winlimit || g_Cvar_Maxrounds)
	{
		new var3 = 0;
		GetGameFolderName(var3, 64);
		if (strcmp(var3, "tf", true))
		{
			if (strcmp(var3, "nucleardawn", true))
			{
				if (strcmp(var3, "empires", true))
				{
					HookEvent("round_end", 41, 1);
				}
				HookEvent("game_end", 41, 1);
			}
			HookEvent("round_win", 41, 1);
		}
		else
		{
			HookEvent("teamplay_win_panel", 45, 1);
			HookEvent("teamplay_restart_round", 43, 1);
			HookEvent("arena_win_panel", 45, 1);
		}
	}
	if (g_Cvar_Fraglimit)
	{
		HookEvent("player_death", 39, 1);
	}
	AutoExecConfig(true, "mapchooser", "sourcemod");
	if (g_Cvar_Bonusroundtime)
	{
		ConVar.SetBounds(g_Cvar_Bonusroundtime, 0, true, 30.0);
	}
	g_NominationsResetForward = GlobalForward.GlobalForward("OnNominationRemoved", 0, 7, 2);
	g_MapVoteStartedForward = GlobalForward.GlobalForward("OnMapVoteStarted", 0);
	return 0;
}

public Action:Timer_ChangeMap(Handle:_arg0, DataPack:_arg1)
{
	g_ChangeMapInProgress = false;
	new var1 = 0;
	if (_arg1)
	{
		DataPack.Reset(_arg1, false);
		DataPack.ReadString(_arg1, var1, 256);
	}
	else
	{
		if (!(GetNextMap(var1, 256)))
		{
			return 4;
		}
	}
	ForceChangeLevel(var1, "Map Vote");
	return 4;
}

public Action:Timer_StartMapVote(Handle:_arg0, DataPack:_arg1)
{
	if (g_RetryTimer == _arg0)
	{
		g_WaitingForVote = false;
		g_RetryTimer = 0;
	}
	else
	{
		g_VoteTimer = 0;
	}
	new var1;
	if (ArrayList.Length.get(g_MapList) && ConVar.BoolValue.get(g_Cvar_EndOfMapVote) && g_MapVoteCompleted && g_HasVoteStarted)
	{
		return 4;
	}
	new var2;
	var2 = DataPack.ReadCell(_arg1);
	new var3;
	var3 = DataPack.ReadCell(_arg1);
	InitiateVote(var2, var3);
	return 4;
}

public void:__ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.BytesLeft.get");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadInt64");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetInt64");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddInt64");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

public void:__pl_mapchooser_SetNTVOptional()
{
	MarkNativeAsOptional("NominateMap");
	MarkNativeAsOptional("RemoveNominationByMap");
	MarkNativeAsOptional("RemoveNominationByOwner");
	MarkNativeAsOptional("GetExcludeMapList");
	MarkNativeAsOptional("GetNominatedMapList");
	MarkNativeAsOptional("CanMapChooserStartVote");
	MarkNativeAsOptional("InitiateMapChooserVote");
	MarkNativeAsOptional("HasEndOfMapVoteFinished");
	MarkNativeAsOptional("EndOfMapVoteEnabled");
	return 0;
}

